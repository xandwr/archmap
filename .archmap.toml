# Archmap Configuration
# This file configures architectural analysis for your project.

[thresholds]
# Maximum lines before a file is flagged as a "god object"
# Default: 500
god_object_lines = 500

# Maximum number of modules importing a single module before flagging high coupling
# Default: 5
coupling_fanin = 5

# Minimum number of boundary violations before reporting
# Default: 2
boundary_violation_min = 2

# Maximum dependency chain depth before flagging (A → B → C → D → E)
# Default: 5
max_dependency_depth = 5

# Minimum cohesion score (ratio of internal vs external dependencies)
# Range: 0.0 to 1.0. Lower scores indicate module is doing too many unrelated things.
# Default: 0.3
min_cohesion = 0.3

# Fat module detection - identifies files with excessive internal complexity
# These are files with many private functions but few exports (hidden sprawl)
# Unlike god objects which have many exports, fat modules hide their complexity
# Test files are automatically excluded from this check
# Default: 400 lines minimum
fat_module_lines = 400
# Default: 8 private functions minimum
fat_module_private_functions = 8
# Default: 100 lines per export maximum
fat_module_lines_per_export = 100.0

# Expected High Coupling
# Glob patterns for modules where high fan-in is expected and shouldn't be flagged.
# Core domain models, config files, and index/entry modules typically have high coupling.
# Default patterns cover common conventions across languages.
expected_high_coupling = [
    "**/model/**",
    "**/models/**",
    "**/types/**",
    "**/config.rs",
    "**/config.ts",
    "**/config.py",
    "**/lib.rs",
    "**/mod.rs",
    "**/index.ts",
    "**/index.js",
    "**/__init__.py",
    # CLI argument definitions - naturally imported by all command handlers
    "**/cli.rs",
    # Terminal styling utilities - stable API used across the codebase
    "**/style.rs",
]

# Architectural Boundaries
# Define patterns that indicate crossing architectural boundaries.
# Scattered boundary crossings often indicate missing abstraction layers.
#
# Each boundary supports:
# - indicators: strings to search for in source code
# - allowed_in: glob patterns for modules where this boundary is allowed (e.g., gateway modules)
# - ownership_threshold: if one module has >= this fraction of occurrences, it's the "owner"
#                        and won't be flagged (default: 0.5)

[boundaries.persistence]
name = "Persistence"
indicators = [
    "sqlx::",
    "diesel::",
    "sea_orm::",
    "prisma.",
    "SELECT ",
    "INSERT ",
    "UPDATE ",
    "DELETE ",
]
suggestion = "Consider centralizing in a repository/data access layer"
# Modules matching these patterns are allowed to cross this boundary
allowed_in = ["**/db/**", "**/database/**", "**/repository/**", "**/repo/**"]

[boundaries.network]
name = "Network"
indicators = [
    "reqwest::",
    "hyper::",
    "fetch(",
    "axios.",
    "requests.",
    "http.get",
    "http.post",
]
suggestion = "Consider centralizing in an API client service"
allowed_in = ["**/client/**", "**/api/**", "**/http/**", "**/network/**"]

[boundaries.filesystem]
name = "Filesystem"
indicators = [
    # Rust
    "std::fs::",
    "tokio::fs::",
    # JavaScript/TypeScript (Node.js)
    "fs.readFile",
    "fs.writeFile",
    "fs.readFileSync",
    "fs.writeFileSync",
    "fs.promises",
    # Python
    "open(",
    "pathlib.Path(",
    "shutil.",
]
suggestion = "Consider centralizing file operations or using dependency injection"
allowed_in = ["**/fs.rs", "**/io.rs", "**/io/**", "**/storage/**"]

# Custom boundaries example (uncomment to use):
# [boundaries.logging]
# name = "Logging"
# indicators = ["log::", "tracing::", "console.log", "print("]
# suggestion = "Consider using a centralized logging facade"
# allowed_in = ["**/logger/**", "**/logging/**"]
# ownership_threshold = 0.6  # Higher threshold = stricter ownership detection
